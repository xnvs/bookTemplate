<link rel="stylesheet" href="/The-book-Developing-Microservices-with-Java-Spring/assets/css/custom.css">

testing main page

## Документация

*   [Страница 1](page1.md)
*   [Страница 2](page2.md)

В эпоху цифровых технологий, когда мир сжимается до размеров экрана, способность эффективно и грамотно коммуницировать становится ключевым навыком. Независимо от того, являетесь ли вы студентом, профессионалом или предпринимателем, четкое, лаконичное и убедительное выражение мыслей – это залог успеха в любой сфере. Письменная речь, как инструмент коммуникации, требует особой аккуратности и внимательности к деталям.


Грамотность – это не просто знание правил орфографии и пунктуации, это умение логично и последовательно излагать свои мысли, аргументировать свою позицию и адаптировать текст к потребностям целевой аудитории. Богатый словарный запас, владение стилистическими приемами и умение строить сложные предложения – все это инструменты, которые помогают сделать текст более выразительным и убедительным.


В современном мире, где информация перегружает нас со всех сторон, умение создавать качественный контент становится особенно ценным. Тексты, которые привлекают внимание, вызывают интерес и запоминаются, – это результат кропотливой работы над каждой деталью. От выбора слов до структуры абзацев, от грамматики до стиля – все эти элементы должны быть согласованы и работать на одну цель: донести до читателя суть сообщения максимально эффективно.

x028. Dynamic Programming: Накопление и Комбинаторика
===
На данный момент мы уже разобрали практически все сложные рекуррентные формулы,
а также то, как работает эскалация кеша. Остаются совсем простые - их,
в принципе, может быть сколько угодно. Предлагаю рассмотреть «накопление»
и «комбинаторику». Более того, стоит отойти от привычной структуры главы,
поскольку эти два подварианта ДП, на мой взгляд, слишком просты (и, думаю,
вы со мной согласитесь).

Итак, у нас есть:

формула накопления:

    dp[i][j] = dp[i-1][j] + dp[i][j-1]

формула комбинаторики:

    dp[i][j] = dp[i-1][j-1] + dp[i][j-1]

Их логический смысл очень прост, хотя на первый взгляд может показаться
неочевидным. Это сразу станет понятно, как только вы взглянете на таблицу.

логика для накопления:
---
это задачи типа доставки, где таблица имеет следующий вид:

    i\j  0  1  2
    0    1  1  1
    1    1  2  3
    2    1  3  6

как видно, каждая следующая эскалация - это по сути комбинация значений
сверху и слева, например:

    i\j  0  1  2
    0    1  1  1
    1    1 [2] 3
    2   [1](3) 6    <- (3) = [1]+[2]

несмотря на кажущуюся очевидность, в задачах с доставкой возможна логическая
ситуация, когда какой-то путь заблокирован (есть установленное препятствие).
в этом случае мы получим:

    dp[i][j] = 0

это означает: «в точку нельзя прийти сверху или слева из определённой клетки».

в целом это не меняет сути дела.
очень просто, очень понятно.

в коде (без препятствий) это выглядит следующим образом:

```java
public class GridPaths {
    public int countPaths(int rows, int cols) {

        // состояние:
        // здесь принципиально нужна таблица
        int[][] dp = new int[rows][cols];

        // базовые случаи:
        // здесь нам надо отметить просто стартовую точку
        dp[0][0] = 1;

        // по первой строке мы можем двигаться только вправо
        for (int j = 1; j < cols; j++) dp[0][j] = 1;

        // по первому столбцу можем двигаться только вниз
        for (int i = 1; i < rows; i++) dp[i][0] = 1;

        // и просто заполняем таблицу (кроме первой строки/столбца)
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {

                // мета формула
                // и здесь же была бы обработка препятствий.
                // из за слишком большой простоты этой главы
                // предлагаю вам сами подумать, как бы это выглядело
                // а я дам корректное решение в практике
                dp[i][j] = dp[i-1][j] + dp[i][j-1];

            }
        }

        return dp[rows-1][cols-1];
    }
}
```
