Header from page
===

some text

some header 
---

some text again 

some header 2
---

content of the page one 

В частности, в рассмотренных трёх задачах компоненты выглядят
таким образом:


```text
компонент   TwoSum                   дубликаты                    ищем цикл
тип         навстречу                разделение                   быстрый/медленный
указатели   left=0, right=n-1        k=1, i=1                     slow=head, fast=head
условие     sum < target ->left++    nums[i] != nums[k-1] ->k++   slow = slow.next
            sum > target ->right--   i++ всегда                   fast = fast.next.next
остановка   left <= right            i < nums.length              fast == null / next == null

```
Связь паттерна с реальным кодом задач (разметка в коде компонентов)
---
так как компонентов слишком мало и они слишком очевидны, показать их в коде
не составит для нас труда, однако на другом типе задач этот паттерн к сожалению
воспроизвести не выйдет, но в целом он вот такой:

```java
public int[] findPair(int[] prices, int target) {

    // <- указатели
    int left = 0;
    int right = prices.length - 1;

    // <- цикл перемещения + критерий установки
    while (left < right) {
        int currentSum = prices[left] + prices[right];

        // <- условие перемещения
        if (currentSum == target)       return new int[]{prices[left], prices[right]};
        else if (currentSum < target)   left++;
        else                            right--;
    }

    // <- ничего не нашли
    return null;
}
```
Всё понятно, но стоит добавить, что часто путают: вместо (left++) делают (right--)
в этой ветке - и наоборот. Поэтому прежде чем кодировать, лучше накидать небольшую
схемку - как я показывал в начале главы.

Вторая распространённая ошибка - (left <= right). По условию должно быть строго «<»
(посмотрите дата флоу - поймёте, почему так).

Дополнительные варианты задач и сравнение компонентов
---
Ну что ж, раз мы так сильно привязаны к отдельным типам задач, давайте подробно
их разберём - с дата флоу и объяснением.

Дополнительно рассмотрим задачи на три-сумму (когда к target ищем не два числа,
которые его образуют, а три). Это логическое усложнение базовой задачи. А также
задачу на контейнеры с дождевой водой - она очень часто встречается на собеседованиях.

Задача на три-сумму:
---
Суть задачи: есть массив {-1, 0, 1, 2, -1, -4}, и мы ищем комбинации из трёх
чисел, которые в сумме дают, например, (0).

Числа должны находиться под индексами [i], [j], [k].

Как ни странно, эта задача не потребует отдельного дата флоу - её идея предельно
проста. Сначала мы, как обычно, отсортируем массив (иначе ничего не сработает!),
а затем будем последовательно перебирать его индексом (i). Для каждого перебора
назначим (j) как (left), а (k) как (right) - и решим задачу о дву-сумме.

В итоге получится:


```java
    <- почему (-2) очевидно, сумма то от i, но еще и j,k (+2)
    for(int i = 0; i < nums.length - 2; i++) {
        здесь решаем задачу для дву-сумме
        и накапливаем решения в массиве решений
    }

```
дата флоу здесь будет таким же, как и понятно, почему это будет работать.

Задача на удаление дубликатов из отсортированного массива:
---
я уже показывал, что это достаточно примитивная задача.
единственное - давайте дополнительно посмотрим на её дата флоу для кейса с
{1,2,3,3,3,4}, который в итоге должен стать {1, 2, 3, 4, _, _} (значения после 4
не будут удаляться - они просто не важны, и мы их в итоге проигнорируем).

Итак, как помните, мы удаляем дубликаты из отсортированного (!) массива.
Это значит, что при наличии дубликатов они у нас начинают идти подряд
один за другим (как в кейсе и видно). Отчего дата флоу движения указателей
будет таким:

так как указателя два, в итоге указатель «i» двигается по всем элементам
(«разведчик-скаут» - так его можно даже назвать в коде, будет чуть легче
читаться), а «k» двигается лишь при наличии уникального элемента
(«накопитель-построитель» - если вам станет от этого проще, называйте его
именно так в коде).

вторая механика - нам нужно как-то подбивать уникальные элементы в левую
сторону. Это происходит в части «действие». На примере 4 мы видим, как она
сдвинулась влево - как раз тогда, когда нашёлся уникальный элемент после
пропускаемой последовательности.


```text
Шаг nums[i]   k    nums[k-1]       Условие nums[i] != nums[k-1]?   Действие

1   2         1    1 (nums[0])     Да (2 != 1)                     nums[1] = 2; k++ → k=2
                                                       после шага: [1, 2, 3, 3, 3, 4]

2   3         2    2 (nums[1])     Да (3 != 2)                     nums[2] = 3; k++ → k=3
                                                       после шага: [1, 2, 3, 3, 3, 4]

3   3         3    3 (nums[2])     Нет (3 == 3)                    Пропускаем (только i++)
                                                       после шага: [1, 2, 3, 3, 3, 4]

4   3         3    3 (nums[2])     Нет (3 == 3)                    Пропускаем (только i++)
                                                       после шага: [1, 2, 3, 3, 3, 4]

5   4         3    3 (nums[2])     Да (4 != 3)                     nums[3] = 4; k++ → k=4
                                                       после шага: [1, 2, 3, 4, 3, 4]

```
всё кажется понятным, двигаемся дальше.
